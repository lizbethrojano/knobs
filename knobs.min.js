/*! Knobs 0.3.5 MIT | https://github.com/yairEO/knobs */

(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Knobs = factory());
}(this, (function () { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn) {
	  var module = { exports: {} };
		return fn(module, module.exports), module.exports;
	}

	/*! Color-Picker 0.10.0 MIT | https://github.com/yairEO/color-picker */

	var colorPicker_min = createCommonjsModule(function (module, exports) {
	!function (t, e) {
	   module.exports = e() ;
	}(commonjsGlobal, function () {
	  var t = t => new DOMParser().parseFromString(t.trim(), "text/html").body.firstElementChild,
	      e = {
	    color: "white",
	    onInput: t => t,
	    onChange: t => t,
	    buttons: {
	      undo: {
	        icon: "↶",
	        title: "Undo"
	      },
	      format: {
	        icon: "⇆",
	        title: "Switch Color Format"
	      },
	      add: {
	        icon: "+",
	        title: "Add to Swatches"
	      }
	    }
	  };
	  const s = t => t.match(/\((.*)\)/)[1].split(",").map(Number),
	        i = t => `hsla(${t.h}, ${t.s}%, ${t.l}%, ${t.a}%)`,
	        o = t => t.toFixed(1).replace(".0", ""),
	        a = t => {
	    const [e, s, i, o] = (t => t.match(/\w\w/g))(t),
	          [a, n, h] = [e, s, i].map(t => parseInt(t, 16));
	    return `rgba(${a},${n},${h},${o ? (parseInt(o, 16) / 255).toFixed(2) : 1})`;
	  },
	        n = t => {
	    var e,
	        s = document.createElement("canvas").getContext("2d");
	    return s.fillStyle = t, "#" == (e = s.fillStyle)[0] ? e : h(e);
	  },
	        h = t => {
	    const [e, i, o, a] = s(t),
	          n = "#" + [e, i, o].map(t => t.toString(16).padStart(2, "0")).join("");
	    return 3 == t.length ? n : n + Math.round(255 * a).toString(16).padStart(2, "0");
	  },
	        r = t => {
	    let [e, i, a, n] = s(t);
	    e /= 255, i /= 255, a /= 255;
	    let h = Math.max(e, i, a),
	        r = Math.min(e, i, a),
	        l = h - r,
	        c = 0,
	        u = 0,
	        d = ((h + r) / 2).toPrecision(5);
	    return l && (u = d > .5 ? l / (2 - h - r) : l / (h + r), c = h == e ? (i - a) / l + (i < a ? 6 : 0) : c = h == i ? (a - e) / l + 2 : (e - i) / l + 4, c /= 6), {
	      h: o(360 * c),
	      s: o(100 * u),
	      l: o(100 * d),
	      a: o(100 * n)
	    };
	  };
	  function l({
	    name: t,
	    min: e = 0,
	    max: s = 100,
	    value: i
	  }) {
	    return `<div class="range color-picker__${t}" title="${t}" style="--min:${e}; --max:${s};">\n            <input type="range" name="${t}" value="${i}" min="${e}" max="${s}">\n            <output></output>\n            <div class='range__progress'></div>\n          </div>`;
	  }
	  function c(t) {
	    const {
	      buttons: {
	        undo: e,
	        format: s
	      }
	    } = this.settings;
	    return `\n    <div class='color-picker__value cp-checkboard'>\n      <input name='value' inputmode='decimal' placeholder='CSS Color' value='${n(i(t))}'>\n      <button title='${e.title}' name="undo">${e.icon}</button>\n      <button title='${s.title}' name='format'>${s.icon}</button>\n      <div></div>\n    </div>\n  `;
	  }
	  function u(t, e) {
	    const {
	      buttons: {
	        add: s
	      }
	    } = this.settings;
	    return `\n    <div class='color-picker__swatches' style='--initial-len:${e.length}'>\n      <button name='addSwatch' title='${s.title}'>${s.icon}</button>\n      ${t.map(t => d(t, e.includes(t))).join("")}\n    </div>\n  `;
	  }
	  function d(t, e) {
	    return `<div class="cp-checkboard color-picker__swatch" title="${t}" style="--c:${t}">${e ? "" : '<button name="removeSwatch">&times;</button>'}</div>`;
	  }
	  var p = Object.freeze({
	    __proto__: null,
	    scope: function () {
	      const {
	        h: t,
	        s: e,
	        l: s,
	        a: i
	      } = this.color;
	      return `\n    <div class='${("color-picker " + (this.settings.className || "")).trim()}'>\n      ${l({
        name: "hue",
        value: t,
        max: "360"
      })}\n      ${l({
        name: "saturation",
        value: e
      })}\n      ${l({
        name: "lightness",
        value: s
      })}\n      ${l({
        name: "alpha",
        value: i
      })}\n      <output></output>\n      ${c.call(this, this.color)}\n      ${this.swatches ? u.call(this, this.swatches, this.initialSwatches) : ""}\n    </div>\n  `;
	    },
	    slider: l,
	    value: c,
	    swatches: u,
	    swatch: d
	  });
	  function S() {
	    this.syncGlobalSwatchesWithLocal();
	  }
	  function m(t) {
	    t.preventDefault();
	    const {
	      value: e,
	      max: s
	    } = t.target,
	          i = -1 * Math.sign(t.deltaY);
	    e && s && (t.target.value = Math.min(Math.max(+e + i, 0), +s), w.call(this, t));
	  }
	  function g(t) {
	    "Escape" == t.key && this.settings.onClickOutside(t);
	  }
	  function v(t) {
	    this.DOM.scope.contains(t.target) || this.settings.onClickOutside(t);
	  }
	  function w(t) {
	    const {
	      name: e,
	      value: s,
	      type: i
	    } = t.target;
	    "range" == i && this.setColor({ ...this.color,
	      [e[0]]: +s
	    });
	  }
	  function f(t) {
	    const {
	      type: e
	    } = t.target;
	    "range" != e && "text" != e || (this.history.last = this.color);
	  }
	  function b(t) {
	    this.setColor(this.getHSLA(t.target.value)), this.DOM.value.blur();
	  }
	  function C(t) {
	    const {
	      name: e,
	      parentNode: s,
	      classList: i,
	      title: o
	    } = t.target;
	    "format" == e ? this.swithFormat() : "undo" == e ? this.history.undo() : "addSwatch" == e ? this.addSwatch() : "removeSwatch" == e ? this.removeSwatch(s, s.title) : i.contains("color-picker__swatch") && o && (this.history.last = this.color, this.setColor(this.getHSLA(o)));
	  }
	  var _ = Object.freeze({
	    __proto__: null,
	    bindEvents: function () {
	      [["scope", "input", w], ["scope", "change", f], ["scope", "click", C], ["scope", "wheel", m], ["value", "change", b]].forEach(([t, e, s]) => this.DOM[t].addEventListener(e, s.bind(this), {
	        pasive: !1
	      })), window.addEventListener("storage", S.bind(this)), this.settings.onClickOutside && (document.body.addEventListener("click", v.bind(this)), window.addEventListener("keydown", g.bind(this)));
	    }
	  });
	  function $() {
	    const t = () => this.settings.onChange(this.CSSColor),
	          e = this.setColor.bind(this);
	    return {
	      _value: [this.color],
	      get pop() {
	        return this._value.pop();
	      },
	      get previous() {
	        return this._value[this._value.length - 2];
	      },
	      set last(e) {
	        this._value.push(e), t();
	      },
	      undo() {
	        if (this._value.length > 1) {
	          this.pop;
	          let s = this._value[this._value.length - 1];
	          return e(s), t(), s;
	        }
	      }
	    };
	  }
	  const y = "@yaireo/color-picker/swatches";
	  var O = Object.freeze({
	    __proto__: null,
	    getSetGlobalSwatches: function (t) {
	      const e = this.settings.swatchesLocalStorage,
	            s = "string" == typeof e ? e : "";
	      return e && t && (localStorage.setItem(y + s, t), dispatchEvent(new Event("storage"))), localStorage[y + s]?.split(",").filter(String) || [];
	    },
	    syncGlobalSwatchesWithLocal: function () {
	      this.sharedSwatches = this.getSetGlobalSwatches(), this.swatches = this.sharedSwatches.concat(this.initialSwatches), this.DOM.swatches && setTimeout(() => {
	        const e = t(this.templates.swatches.call(this, this.swatches, this.initialSwatches));
	        this.DOM.swatches.replaceWith(e), this.DOM.swatches = e;
	      }, 500);
	    },
	    addSwatch: function (e = this.CSSColor) {
	      if (((t, e) => t.some(t => (console.log(n(t), n(e), n(t) == n(e)), n(t) == n(e))))(this.swatches, e)) return;
	      const s = t(this.templates.swatch(e));
	      s.classList.add("cp_remove"), this.DOM.swatches.prepend(s), setTimeout(() => s.classList.remove("cp_remove"), 0), this.swatches.unshift(e), this.sharedSwatches.unshift(e), this.getSetGlobalSwatches(this.sharedSwatches);
	    },
	    removeSwatch: function (t, e) {
	      t.classList.add("cp_remove"), setTimeout(() => t.remove(), 200);
	      const s = t => t != e;
	      this.swatches = this.swatches.filter(s), this.sharedSwatches = this.sharedSwatches.filter(s), this.getSetGlobalSwatches(this.sharedSwatches);
	    }
	  });
	  function M(t) {
	    this.settings = Object.assign({}, e, t);
	    const {
	      color: s,
	      defaultFormat: i,
	      swatches: o
	    } = this.settings;
	    this.DOM = {}, this.sharedSwatches = this.getSetGlobalSwatches(), this.initialSwatches = o || [], this.swatches = o && this.sharedSwatches.concat(this.initialSwatches), this.setColor(this.getHSLA(this.changeColorFormat(s, i))), this.history = $.call(this), this.init();
	  }
	  return M.prototype = {
	    templates: p,
	    ...O,
	    ..._,
	    getColorFormat: t => "#" == t[0] ? "hex" : t.indexOf("hsl") ? t.indexOf("rgb") ? "" : "rgba" : "hsla",
	    changeColorFormat: (t, e) => (e = (e + "").toLowerCase(), t = n(t), "hex" == e ? t : e.startsWith("hsl") ? i(r(a(t))) : e.startsWith("rgb") ? a(t) : t),
	    getHSLA(t) {
	      let e;
	      var s;
	      return this.colorFormat = this.getColorFormat(t), t.indexOf("hsla") ? (t = n(t), t = a(t), e = r(t)) : (s = t, e = Object.assign([0, 0, 0, 1], s.match(/\((.*)\)/)[1].split(",").map((t, e) => 3 != e || t.includes("%") ? parseFloat(t) : 100 * parseFloat(t))), e = {
	        h: e[0],
	        s: e[1],
	        l: e[2],
	        a: e[3]
	      }), e;
	    },
	    swithFormat() {
	      switch (this.colorFormat) {
	        case "":
	        case "hex":
	          this.colorFormat = "rgba";
	          break;
	        case "rgba":
	          this.colorFormat = "hsla";
	          break;
	        case "hsla":
	          this.colorFormat = "hex";
	      }
	      this.setCSSColor(), this.DOM.value.value = this.CSSColor;
	    },
	    updateRangeSlider(t, e) {
	      const s = this.DOM.scope.querySelector(`input[name="${t}"]`);
	      s && (s.value = e, s.parentNode.style.setProperty("--value", e), s.parentNode.style.setProperty("--text-value", JSON.stringify("" + Math.round(e))), this.updateCSSVar(t, e));
	    },
	    setCSSColor() {
	      this.CSSColor = n(i(this.color)), "rgba" == this.colorFormat ? this.CSSColor = a(this.CSSColor) : "hsla" == this.colorFormat && (this.CSSColor = i(this.color)), this.DOM.scope && this.DOM.scope.setAttribute("data-color-format", this.colorFormat), this.settings.onInput(this.CSSColor);
	    },
	    setColor(t) {
	      t && (this.color = t, this.setCSSColor(), this.DOM.scope && this.updateAllCSSVars(), this.DOM.value && (this.DOM.value.value = this.CSSColor));
	    },
	    updateCSSVar(t, e) {
	      this.DOM.scope.style.setProperty("--" + t, e);
	    },
	    updateAllCSSVars() {
	      const t = this.NamedHSLA(this.color);
	      Object.entries(t).forEach(([t, e]) => {
	        this.updateRangeSlider(t, e);
	      });
	    },
	    NamedHSLA: t => ({
	      hue: t.h,
	      saturation: t.s,
	      lightness: t.l,
	      alpha: t.a
	    }),
	    build() {
	      const e = this.templates.scope.call(this);
	      this.DOM.scope = t(e), this.DOM.value = this.DOM.scope.querySelector('input[name="value"]'), this.DOM.swatches = this.DOM.scope.querySelector(".color-picker__swatches");
	    },
	    init() {
	      this.build(), this.setColor(this.color), this.bindEvents();
	    }
	  }, M;
	});
	});

	/*! NanoPop 2.1.0 MIT | https://github.com/Simonwep/nanopop */
	const e = {
	  variantFlipOrder: {
	    start: "sme",
	    middle: "mse",
	    end: "ems"
	  },
	  positionFlipOrder: {
	    top: "tbrl",
	    right: "rltb",
	    bottom: "btrl",
	    left: "lrbt"
	  },
	  position: "bottom",
	  margin: 8
	},
	      r = (t, r, o) => {
	  const {
	    container: n,
	    margin: i,
	    position: p,
	    variantFlipOrder: s,
	    positionFlipOrder: l
	  } = {
	    container: document.documentElement.getBoundingClientRect(),
	    ...e,
	    ...o
	  },
	        {
	    left: c,
	    top: f
	  } = r.style;
	  r.style.left = "0", r.style.top = "0";
	  const m = t.getBoundingClientRect(),
	        a = r.getBoundingClientRect(),
	        b = {
	    t: m.top - a.height - i,
	    b: m.bottom + i,
	    r: m.right + i,
	    l: m.left - a.width - i
	  },
	        d = {
	    vs: m.left,
	    vm: m.left + m.width / 2 + -a.width / 2,
	    ve: m.left + m.width - a.width,
	    hs: m.top,
	    hm: m.bottom - m.height / 2 - a.height / 2,
	    he: m.bottom - a.height
	  },
	        [h, u = "middle"] = p.split("-"),
	        v = l[h],
	        g = s[u],
	        {
	    top: O,
	    left: F,
	    bottom: x,
	    right: j
	  } = n;
	  for (const t of v) {
	    const e = "t" === t || "b" === t,
	          o = b[t],
	          [n, i] = e ? ["top", "left"] : ["left", "top"],
	          [p, s] = e ? [a.height, a.width] : [a.width, a.height],
	          [l, c] = e ? [x, j] : [j, x],
	          [f, m] = e ? [O, F] : [F, O];
	    if (!(o < f || o + p > l)) for (const p of g) {
	      const l = d[(e ? "v" : "h") + p];
	      if (!(l < m || l + s > c)) return r.style[i] = l - a[i] + "px", r.style[n] = o - a[n] + "px", t + p;
	    }
	  }
	  return r.style.left = c, r.style.top = f, null;
	};

	var mainStyles = "﻿label,button,input{cursor:pointer;font:12px Arial, sans-serif}body,form{padding:0;margin:0}#knobsToggle+.knobs>label{--size: calc(var(--toggleSize)/2);--offset: calc(var(--toggleOffset));position:absolute;width:var(--size);height:var(--size);top:var(--offset);right:var(--offset);padding:calc((var(--toggleSize) - var(--size))/2);font-size:20px;line-height:1;z-index:1;color:var(--textColor)}#knobsToggle:not(:checked)+.knobs>label:hover+.knobs__bg{opacity:1;transform:scale(1.15)}#knobsToggle:checked+.knobs{display:inline-block}#knobsToggle:checked+.knobs>label{padding:0}#knobsToggle:checked+.knobs .knobs__bg{--corner-radius: 8px;--offset: calc(var(--corner-radius) * -1);top:var(--offset);right:var(--offset);bottom:var(--offset);left:var(--offset);border-radius:var(--corner-radius);margin:0;width:calc(100% + var(--corner-radius));height:calc(100% + var(--corner-radius));opacity:1;transition:0.3s cubic-bezier(0.45, 0, 0.2, 1),margin 0.2s,border-radius 0.2s}#knobsToggle:checked+.knobs .knobs__labels{transform:none;transition:calc(var(--in-duration) * 1s) var(--in-easing)}#knobsToggle:checked+.knobs .knobs__labels fieldset,#knobsToggle:checked+.knobs .knobs__labels .knobs__controls{transform:none;opacity:1;transition:calc(var(--in-duration) * 1s) calc(var(--in-duration) * .5s) ease-out}html,body{overflow:hidden}.knobs{--range-track-color: var(--primaryColor);--knobs-gap: 3px;--side-pad: 12px;--toggleSize: 40px;--toggleOffset: 6px;--in-easing: cubic-bezier(.75,0,.35,1);--in-duration: .3;--color-size: 20px;--knobs-group-transition: .33s cubic-bezier(.45, 0, .2, 1);--LTR-Bool: 1;font:12px/1 'Fira Sans Condensed', sans-serif;color:var(--textColor);position:relative;overflow:hidden}.knobs[data-flow='compact']{--color-size: 16px}.knobs[data-flow='compact'] label[data-type='range']{flex-flow:column}.knobs[data-flow='compact'] label[data-type='range'] .range{--thumb-size: 12px;--track-height: calc(var(--thumb-size)/2)}.knobs[data-flow='compact'] label[data-type='range'] ~ .knobs__knob__reset{align-self:flex-start;margin-top:.5ch}.knobs[data-flow='compact'] label[data-type='range'] .knobs__label{margin:0;padding:0}.knobs label{user-select:none;cursor:pointer}.knobs__bg{position:absolute;top:0;right:0;margin:var(--toggleOffset);width:var(--toggleSize);height:var(--toggleSize);border-radius:50%;background:var(--background);opacity:.8;transition:120ms}.knobs__labels{border:var(--border);transform:translateX(calc(100.1% * var(--LTR-Bool)));overflow:hidden}.knobs__labels fieldset{display:table;border:0;padding:0;margin:var(--side-pad);opacity:0;transform:translateX(calc(22% * var(--LTR-Bool)));overflow:hidden}.knobs__labels fieldset:only-of-type>label{pointer-events:none}.knobs__labels fieldset:first-child{margin-top:calc(var(--side-pad) * 2.5)}.knobs__labels fieldset:first-child:not([data-has-legend]){overflow:visible}.knobs__labels .fieldset__group{transition:var(--knobs-group-transition)}.knobs__labels hr{border:0;border-top:1px solid var(--textColor);opacity:.25}.knobs__labels hr:last-of-type{margin-bottom:0}.knobs__labels label{order:5;flex:1;display:flex;position:relative;z-index:1;background:var(--background)}.knobs__labels label>*{padding:var(--knobs-gap, 6px) 0}.knobs__labels .range,.knobs__labels input[type=text]{min-width:200px}.knobs__labels label>:last-child{flex:1;text-align:right}.knobs__legend{display:flex;align-items:center;margin:0 0 var(--side-pad);font-weight:700;opacity:.66;cursor:pointer;transition:0.2s cubic-bezier(0.45, 0, 0.2, 1)}.knobs__legend::before,.knobs__legend::after{content:'';height:1px;background:var(--textColor);flex:1;opacity:.5;transition:inherit}.knobs__legend::before{margin-right:2ch}.knobs__legend::after{margin-left:2ch}.knobs__legend:hover:not(:active){opacity:.85}.knobs__legend:hover:not(:active)::before{margin-right:6ch}.knobs__legend:hover:not(:active)::after{margin-left:6ch}.knobs__knob{display:flex;position:relative}.knobs__knob:hover .knobs__knob__label{opacity:1}.knobs__knob[data-changed] .knobs__knob__reset{opacity:.75;pointer-events:auto}.knobs__knob[data-changed] .knobs__knob__reset:hover{opacity:1;background:var(--textColor);color:var(--background);transition:0s}.knobs__knob__toggle{display:var(--knobs-toggle, none);order:1;align-self:center;margin:0 5px 0 0;appearance:none;width:12px;height:12px;outline:none;border-radius:50%;position:relative;text-align:center;line-height:10px}.knobs__knob__toggle::before{content:'';position:absolute;top:0;right:0;bottom:0;left:0;border:1px solid var(--textColor);opacity:.4;border-radius:3px}.knobs__knob__toggle:checked::after{content:'✔';color:var(--textColor);font-size:12px;text-shadow:-1px -2px var(--background),4px -2px var(--background);position:relative;z-index:1}.knobs__knob__toggle:not(:checked) ~ *{pointer-events:none !important}.knobs__knob__toggle:not(:checked) ~ label>*{filter:grayscale(100%);opacity:.4;transition:.2s}.knobs__knob__reset{order:0;pointer-events:none;margin-right:.5em;padding:0;align-self:center;color:inherit;background:none;border:0;cursor:pointer;opacity:.33;outline:none;border-radius:50%;width:2ch;height:2ch;transition:.15s ease-out}.knobs__knob__label{margin-right:2ch;white-space:nowrap;display:flex;align-items:center;opacity:.8;transition:80ms}.knobs__knob__label::after{content:attr(data-units);opacity:.5;margin-left:1ch}.knobs .toggleSection:not(:checked) ~ .fieldset__group{opacity:0;margin-top:calc(-1em + var(--height) * -1px);text-shadow:0px 3px 2px}.leversIcon{width:56px;transform:scale(0.4);transform-origin:0 0}.leversIcon>div{display:flex;align-items:center;transition:transform .2s ease}.leversIcon>div:nth-child(1)::before{flex:.33;transition-delay:.3s}.leversIcon>div:nth-child(2){margin:2px 0}.leversIcon>div:nth-child(2)::after{flex:.33}.leversIcon>div:nth-child(3)::before{flex:.8;transition-delay:.1s}.leversIcon>div>b{display:inline-block;width:7.5px;height:7.5px;border-radius:50%;border:4px solid currentColor;margin:0 5px}.leversIcon>div::before,.leversIcon>div::after{content:'';height:5px;background:currentColor;border-radius:5px;flex:1;transition:flex .1s ease}.leversIcon>div::after{flex:auto;opacity:.33}@keyframes leversIcon{30%{flex:.2}80%{flex:5}}#knobsToggle:not(:checked)+.knobs>label:hover .leversIcon>div:nth-child(1)::before{animation:1s leversIcon ease infinite}#knobsToggle:not(:checked)+.knobs>label:hover .leversIcon>div:nth-child(2){margin:1px 0}#knobsToggle:not(:checked)+.knobs>label:hover .leversIcon>div:nth-child(2)::after{animation:1s .1s leversIcon ease reverse infinite}#knobsToggle:not(:checked)+.knobs>label:hover .leversIcon>div:nth-child(3)::before{animation:1.2s .15s leversIcon ease alternate infinite}#knobsToggle:checked+.knobs>label{--size: 18px;--offset: calc(var(--toggleOffset) + var(--size)/3)}#knobsToggle:checked+.knobs>label .leversIcon{width:65px;color:var(--textColor);transition:color .2s;transform:scale(0.3) translate(0, 6px);opacity:.7}#knobsToggle:checked+.knobs>label .leversIcon:hover{opacity:1}#knobsToggle:checked+.knobs>label .leversIcon b{transform:scale(0);margin:0;width:0}#knobsToggle:checked+.knobs>label .leversIcon>div::after{flex:0}#knobsToggle:checked+.knobs>label .leversIcon>div::before{flex:3;height:8px}#knobsToggle:checked+.knobs>label .leversIcon>div:nth-child(1){transform:rotate(45deg);transform-origin:20% 50%}#knobsToggle:checked+.knobs>label .leversIcon>div:nth-child(2){opacity:0}#knobsToggle:checked+.knobs>label .leversIcon>div:nth-child(3){transform:rotate(-45deg);transform-origin:0 0}#knobsToggle:checked+.knobs[data-position~='top'] .knobs__bg{bottom:auto}#knobsToggle:checked+.knobs[data-position~='right'] .knobs__bg{left:auto}#knobsToggle:checked+.knobs[data-position~='bottom']>label{top:auto;bottom:var(--offset)}#knobsToggle:checked+.knobs[data-position~='bottom'] .knobs__bg{top:auto}#knobsToggle:checked+.knobs[data-position~='bottom'][data-position~='right']{--control-right-pad: var(--toggleSize)}#knobsToggle:checked+.knobs[data-position~='left']>label{right:auto;left:var(--offset)}#knobsToggle:checked+.knobs[data-position~='left'] .knobs__bg{right:auto}#knobsToggle:checked+.knobs[data-position~='left'][data-position~='bottom']{--control-left-pad: var(--toggleSize)}.knobs[data-position~='left']{--LTR-Bool: -1}.knobs .range{--fill-color: var(--range-track-color);--primaryColor: var(--range-value-background);--value-active-color: var(--range-track-color);--value-background: transparent;--progress-color: #444;--thumb-size: 20px;--track-height: calc(var(--thumb-size)/3);--thumb-shadow: 0 0 3px rgba(0,0,0,.2);--ticks-thickness: 1px;--ticks-height: 0px;--show-min-max: none;color:transparent}.knobs .range>input:hover+output{box-shadow:0 0 0 3px var(--value-background),0 0 6px 4px var(--background)}.range{--primaryColor: #0366D6;--value-active-color: white;--value-background: white;--value-font: 700 12px/1 Arial;--progress-color: #EEE;--progress-shadow: 2px 2px 4px rgba(0,0,0, .1) inset;--fill-color: var(--primaryColor);--thumb-size: 16px;--track-height: calc(var(--thumb-size)/2);--thumb-shadow: 0 0 3px rgba(0,0,0,.2);--ticks-thickness: 1px;--ticks-height: 5px;--ticks-color: silver;--step: 1;--ticks-count: (var(--max) - var(--min)) / var(--step);--maxTicksAllowed: 30;--too-many-ticks: Min(1, Max(var(--ticks-count) - var(--maxTicksAllowed), 0));--x-step: Max( var(--step), var(--too-many-ticks) * (var(--max) - var(--min)) );--tickInterval: 100/((var(--max) - var(--min)) / var(--step)) * var(--tickEvery, 1);--tickIntervalPerc: calc((100% - var(--thumb-size))/( (var(--max) - var(--min)) / var(--x-step) ) * var(--tickEvery, 1));--completed: calc((var(--value) - var(--min) ) / (var(--max) - var(--min)) * 100);--LTR: 1;display:inline-block;height:Max(var(--track-height), var(--thumb-size));background:linear-gradient(to right, var(--ticks-color) var(--ticks-thickness), transparent 1px) repeat-x;background-size:var(--tickIntervalPerc) var(--ticks-height);background-position-x:calc(var(--thumb-size)/2);background-position-y:var(--flip-y, bottom);position:relative;z-index:1;padding-bottom:var(--flip-y, var(--ticks-height));padding-top:calc(var(--flip-y) * var(--ticks-height))}[dir=\"rtl\"] .range{--LTR: -1}.range[data-ticks-position='top']{--flip-y: 1}.range::before,.range::after{--offset: calc(var(--thumb-size)/2);content:counter(x);display:var(--show-min-max, block);font:12px Arial;position:absolute;bottom:var(--flip-y, -2.5ch);top:calc(-2.5ch * var(--flip-y));opacity:var(--min-max-opacity, 0.5);pointer-events:none}.range::before{counter-reset:x var(--min);left:var(--offset);transform:translateX(calc(-50% * var(--LTR)))}[dir='rtl'] .range::before{left:auto;right:var(--offset)}.range::after{counter-reset:x var(--max);right:var(--offset);transform:translateX(calc(50% * var(--LTR)))}[dir='rtl'] .range::after{right:auto;left:var(--offset)}.range__progress{position:absolute;left:0;top:calc(50% - var(--ticks-height)/2);transform:var(--flip-y, translateY(-50%) translateZ(0));width:100%;height:calc(var(--track-height));pointer-events:none;z-index:-1;box-shadow:var(--progress-shadow);border-radius:20px;background:var(--fill-color, white)}.range__progress::after{content:'';display:block;margin-left:auto;margin-right:-1px;width:calc((100% - var(--completed) * 1%) + (var(--completed)/100) * var(--thumb-size)/2);height:100%;background:var(--progress-color, #EEE);box-shadow:inherit;border-radius:0 20px 20px 0}[dir=\"rtl\"] .range__progress::after{margin-right:auto;margin-left:-1px;border-radius:20px 0 0 20px}.range>input{-webkit-appearance:none;width:100%;height:var(--thumb-size);margin:0;cursor:-webkit-grab;cursor:grab;outline:none;background:none}.range>input::-webkit-slider-thumb{appearance:none;height:var(--thumb-size);width:var(--thumb-size);border-radius:50%;background:var(--thumb-color, white);border:1px solid silver;box-shadow:var(--inner-shadow, 0 0),var(--thumb-shadow)}.range>input::-moz-slider-thumb{appearance:none;height:var(--thumb-size);width:var(--thumb-size);border-radius:50%;background:var(--thumb-color, white);border:1px solid silver;box-shadow:var(--inner-shadow, 0 0),var(--thumb-shadow)}.range>input::-ms-thumb{appearance:none;height:var(--thumb-size);width:var(--thumb-size);border-radius:50%;background:var(--thumb-color, white);border:1px solid silver;box-shadow:var(--inner-shadow, 0 0),var(--thumb-shadow)}.range>input:active{cursor:grabbing;--thumb-color: var(--fill-color);--inner-shadow: 0 0 0 calc(var(--thumb-size)/4) inset white}.range>input:active+output{transition:0s}.range>input:hover+output{--value-background: var(--primaryColor);color:var(--value-active-color);transform:translate(var(--x-offset), 0);box-shadow:0 0 0 3px var(--value-background)}.range>output{--x-offset: calc(var(--completed) * -1% * var(--LTR));--pos: calc(((var(--value) - var(--min))/(var(--max) - var(--min))) * 100%);pointer-events:none;position:absolute;z-index:5;background:var(--value-background);border-radius:10px;padding:0 4px;top:-3ch;left:var(--pos);transform:translate(var(--x-offset), 6px);transition:all .12s ease-out, left 0s, top 0s}[dir='rtl'] .range>output{left:auto;right:var(--pos)}.range>output::after{content:var(--text-value);font:var(--value-font)}.knobs .switch{--color-bg: #444;--color-bg-on: #444;--thumb-color-off: #d75d4a;--thumb-color-on: #4ec964;--thumb-scale: 1.1;--width-multiplier: 2.5;--thumb-animation-pad: 15%;--size: 11px}.knobs .switch input:focus+div{outline:none}.switch{--color-bg: #E1E1E1;--color-bg-on: #16B5FF;--thumb-color-on: white;--thumb-color-off: var(--thumb-color-on);--thumb-scale: 1;--size: 16px;--duration: .18s;--width-multiplier: 2.5;--thumb-animation-pad: 15%;user-select:none;display:inline-flex;align-items:center}@keyframes switchMoveThumb{50%{padding:0 var(--thumb-animation-pad)}}@keyframes switchMoveThumb1{50%{padding:0 var(--thumb-animation-pad)}}.switch--textRight .switch__label{order:10;padding:0 0 0 .4em}.switch>div{cursor:pointer}.switch__label{order:0;padding-right:.4em;color:var(--label-color)}.switch__gfx{--thumb-left: 0%;--transform: translateX(calc(var(--thumb-left) * -1)) scale(var(--thumb-scale));order:5;padding:3px;position:relative;background:var(--bg, var(--color-bg));border-radius:50px;width:calc(var(--size) * var(--width-multiplier));transition:var(--duration);background-size:4px 4px}.switch__gfx::before{content:'';display:block;position:relative;left:var(--thumb-left);background:var(--thumb-color, var(--thumb-color-off));border-radius:var(--size);width:var(--size);height:var(--size);transform:var(--transform);transition:var(--duration);animation:switchMoveThumb var(--duration) ease 1}.switch input{position:absolute;opacity:0}.switch input[disabled]+div{background-image:linear-gradient(45deg, #fff 25%, transparent 25%, transparent 50%, #fff 50%, #fff 75%, transparent 75%)}.switch input:disabled ~ div{cursor:not-allowed}.switch input:indeterminate+div{--thumb-left: 50%}.switch input:checked+div{--bg: var(--color-bg-on);--thumb-left: 100%;--thumb-color: var(--thumb-color-on)}.switch input:checked+div::before{animation-name:switchMoveThumb1}.switch input:focus+div{outline:1px dotted silver}.switch input:focus:not(:focus-visible)+div{outline:none}.knobs__controls{display:flex;align-items:center;opacity:0;flex-direction:row-reverse;margin:var(--side-pad) var(--control-right-pad, var(--side-pad)) var(--side-pad) var(--control-left-pad, var(--side-pad));position:relative;z-index:1}.knobs__controls>input{color:var(--textColor);border:0;background:none;margin-left:1em;line-height:1}.poweredBy{margin-right:auto;text-decoration:none;color:inherit;padding:3px;font-size:10px;opacity:.5;transition:.15s}.poweredBy:hover{color:var(--primaryColor);opacity:1}label[data-type=\"color\"]>.knobs__knob__inputWrap>div{display:inline-block;border-radius:50px;overflow:hidden;width:var(--color-size);height:var(--color-size);transition:0.3s var(--in-easing);box-shadow:0px 0px 7px -2px currentColor;background:white repeating-conic-gradient(#DDD 0% 25%, transparent 0% 50%) 0/7px 7px}label[data-type=\"color\"]:hover>.knobs__knob__inputWrap>div{width:calc(var(--color-size) * 3)}label[data-type=\"color\"] input{width:100%;height:100%;border:0;background:var(--value);color:transparent;outline:none;caret-color:transparent;text-transform:uppercase;font-weight:600}label[data-type=\"color\"] input::selection{color:transparent}\n";

	var colorPickerStyles = ".color-picker .range{--tickEvery: 400;--primaryColor: #000;--progress-color: transparent;--progress-shadow: unset;--value-active-color: white;--value-background: white;--value-font: 700 12px/1 Arial;--fill-color: var(--primaryColor);--thumb-size: 21px;--track-height: calc(var(--thumb-size)/1.5);--thumb-shadow: 0 0 3px rgba(0,0,0,.2);--step: 1;--completed: calc((var(--value) - var(--min) ) / (var(--max) - var(--min)) * 100);--show-min-max: none;--LTR: 1;display:inline-block;height:Max(var(--track-height), var(--thumb-size));background:none;position:relative;z-index:1;padding-bottom:0;padding-top:0;margin:0 0 calc((var(--thumb-size) - var(--track-height)) * -1)}.color-picker .range__progress{position:absolute;left:0;top:50%;transform:translateY(-50%) translateZ(0);width:100%;height:calc(var(--track-height));pointer-events:none;z-index:-1;box-shadow:var(--progress-shadow);border-radius:20px;background:var(--fill-color, white)}.color-picker .range__progress::after{content:unset}.color-picker .range>input{--thumb-color: transparent;--inner-shadow: 0 0 0 calc(var(--thumb-size)/8) inset white;-webkit-appearance:none;width:100%;height:var(--thumb-size);margin:0;cursor:-webkit-grab;cursor:grab;outline:none;background:none}.color-picker .range>input::-webkit-slider-thumb{appearance:none;height:var(--thumb-size);width:var(--thumb-size);border-radius:50%;background:var(--thumb-color, white);border:1px solid silver;box-shadow:var(--inner-shadow, 0 0),var(--thumb-shadow)}.color-picker .range>input::-moz-slider-thumb{appearance:none;height:var(--thumb-size);width:var(--thumb-size);border-radius:50%;background:var(--thumb-color, white);border:1px solid silver;box-shadow:var(--inner-shadow, 0 0),var(--thumb-shadow)}.color-picker .range>input:active{cursor:grabbing}.color-picker .range>input:active+output{transition:0s}.color-picker .range>input:hover+output{--value-background: var(--primaryColor);opacity:1;color:var(--value-active-color);transform:translate(var(--x-offset), 0);box-shadow:0 0 0 3px var(--value-background)}.color-picker .range>output{--x-offset: calc(var(--completed) * -1% * var(--LTR));--pos: calc(((var(--value) - var(--min))/(var(--max) - var(--min))) * 100%);opacity:0;pointer-events:none;position:absolute;z-index:5;background:var(--value-background);border-radius:10px;padding:0 4px;top:-3.5ch;left:var(--pos);transform:translate(var(--x-offset), 6px);transition:all .12s ease-out, left 0s, top 0s}.color-picker .range>output::before{--size: 5px;content:'';top:calc(100% + 2px);left:50%;border:solid transparent;height:0;width:0;position:absolute;pointer-events:none;border-top-color:var(--value-background);border-width:var(--size);margin-left:calc(var(--size) * -1);transition:inherit}.color-picker .range>output::after{content:var(--text-value);font:var(--value-font)}.color-picker{--hue: 150;--saturation: 100;--lightness: 50;--alpha: 100;--s: calc(var(--saturation) * 1%);--l: calc(var(--lightness) * 1%);--a: calc(var(--alpha) * 1%);--color: hsla(var(--hue), var(--s), var(--l), var(--a));--checkboard-color: #DDD;--checkboard-base-gradient: repeating-conic-gradient(var(--checkboard-color) 0% 25%, transparent 0% 50%);--width: 320;--width-units: 1px;display:flex;flex-flow:column;gap:.5em;width:calc(var(--width) * var(--width-units));position:relative;box-sizing:border-box;transition:opacity .15s, transform .15s;transition-timing-function:ease-out}.color-picker__hue.range{grid-area:hue;--fill-color: linear-gradient(to right, red 0%, #ff0 16.6%, lime 33.3%, cyan 50%, blue 66.6%, #f0f 83.3%, red 100%)}.color-picker__saturation.range{grid-area:saturation;--fill-color: linear-gradient(to right, white, hsl(var(--hue),var(--s), 50%))}.color-picker__lightness.range{grid-area:lightness;--c: hsl(var(--hue), var(--s), 50%);--fill-color: linear-gradient(to right, black, var(--c), white)}.color-picker__alpha.range{grid-area:alpha;--checkboard-size: calc(var(--track-height)/2);--fill-color: linear-gradient(to right, transparent, hsl(var(--hue), var(--s), var(--l))),\r\n                  var(--checkboard-base-gradient)\r\n                  0 / var(--checkboard-size) var(--checkboard-size)}.color-picker button{cursor:pointer;border:none;background:none;outline:none}.cp-checkboard::before{content:'';position:absolute;z-index:-1;top:0;bottom:0;left:0;right:0;border-radius:inherit;background:repeating-conic-gradient(var(--checkboard-color) 0% 25%, transparent 0% 50%) 0/12px 12px}.color-picker>output{grid-area:color;border-radius:5px;overflow:hidden;position:relative;width:50px;background:hsla(var(--hue), var(--s), var(--l), var(--a));box-shadow:0 0 8px -5px}.color-picker>output::before{content:'';position:absolute;z-index:-1;top:0;bottom:0;left:0;right:0;background:repeating-conic-gradient(var(--checkboard-color) 0% 25%, transparent 0% 50%) 0/12px 12px}.color-picker.hidden{opacity:0;pointer-events:none;transform:scale(0.95)}.color-picker[style~='left:']{position:absolute;z-index:999999;border-radius:10px;padding:.5em;box-shadow:0 0 20px rgba(0,0,0,0.25);backdrop-filter:blur(3px);background-color:rgba(255,255,255,0.5)}@media only screen and (max-device-width: 640px){.color-picker[style~='left:']{max-width:70%}}.color-picker__value{--isLightColor: Min(1, Max(60 - var(--lightness) - (100 - var(--alpha)), 0));grid-area:value;position:relative;display:inline-flex;align-items:center;overflow:hidden;border-radius:10px;color:hsl(var(--hue), 100%, calc(var(--isLightColor) * 100%));box-shadow:0 0 4px rgba(0,0,0,0.2)}.color-picker__value input{flex:1;order:2;cursor:text;width:0;letter-spacing:-.5px;word-spacing:-3px;font:800 16px/2 monospace;font-size:calc(var(--width)*var(--width-units)/ 20);text-transform:uppercase;padding:0;text-align:center;border:none;outline:none;background:none;color:inherit;transition:color .2s}.color-picker__value input ~ div{position:absolute;z-index:-1;top:0;bottom:0;left:0;right:0;border-radius:inherit;background:var(--color)}.color-picker__value input:focus{color:black}.color-picker__value input:focus ~ button{transform:translateX(100%)}.color-picker__value input:focus+button{transform:translateX(-100%)}.color-picker__value input:focus ~ div{background:none;transition:background .15s;border:3px solid var(--color)}.color-picker__value>button{order:3;width:1.5em;background:none;border:none;font:22px/1.2 monospace;outline:none;color:inherit;cursor:pointer;user-select:none;transition:color .2s, transform .2s ease-out}.color-picker__value>button[name='undo']{order:1}.color-picker__swatches{display:flex;flex-wrap:wrap;align-items:center;gap:3px}.color-picker__swatches>button{--shadow-size: 2px;order:0;padding:12px;width:0;height:0;border-radius:50%;background:var(--c);font-size:18px;line-height:1px;text-indent:-6px;transition:.1s;box-shadow:0 0 0 var(--shadow-size) inset var(--color)}.color-picker__swatches>button:hover:not(:active){--shadow-size: 4px}.color-picker__swatch{order:1;padding:12px;line-height:0;border-radius:50%;background:var(--c);position:relative;cursor:pointer;transition:.15s ease-in-out}.color-picker__swatch:hover{transition:50ms}.color-picker__swatch:hover>button{opacity:1}.color-picker__swatch.cp_remove{padding:0;pointer-events:none;transition:.2s}.color-picker__swatch>button{opacity:0;position:absolute;top:0;right:0;width:0;height:0;border-radius:50%;line-height:.1;color:black;font-weight:800;text-shadow:0 3px white, -2px 1px white}\n";

	function isObject(obj) {
	  return obj + "" === "[object Object]";
	}

	function mergeDeep(target, ...sources) {
	  if (!sources.length) return target;
	  const source = sources.shift();
	  if (isObject(target) && isObject(source)) {
	    for (const key in source) {
	      if (isObject(source[key])) {
	        if (!target[key]) Object.assign(target, {
	          [key]: {}
	        });
	        mergeDeep(target[key], source[key]);
	      } else {
	        Object.assign(target, {
	          [key]: source[key]
	        });
	      }
	    }
	  }
	  return mergeDeep(target, ...sources);
	}

	var isModernBrowser = (() => window.CSS && CSS.supports('top', 'var(--a)'));

	function cloneKnobs (knobs, persistedData) {
	  return knobs.map(k => {
	    if (k && k.type) {
	      k.__name = k.__name || k.label.replace('/ /g', '-') + Math.random().toString(36).slice(-6);
	      k.defaultValue = k.defaultValue ?? k.value ?? this.getKnobValueFromCSSVar(k);
	      k.defaultChecked = k.defaultChecked ?? !!k.checked;
	      if (persistedData) {
	        if (k.type == 'checkbox') {
	          k.checked = persistedData[k.label]?.[0] ?? k.defaultChecked;
	        } else k.value = persistedData[k.label] ?? k.defaultValue;
	      }
	      if (k.type == 'range') {
	        k.value = +k.value;
	        k.defaultValue = +k.defaultValue;
	      }
	    }
	    return k.cssVar ? { ...k,
	      cssVar: [...k.cssVar]
	    } : isObject(k)
	    ? { ...k
	    } : k;
	  });
	}

	var settingsIcon = `<div class='leversIcon'>
  <div><b></b></div>
  <div><b></b></div>
  <div><b></b></div>
</div>
`;
	function scope() {
	  const {
	    visible,
	    live,
	    theme
	  } = this.settings;
	  return `
    <input hidden type='checkbox' ${visible ? 'checked' : ''} id='knobsToggle' />
    <aside class='knobs' data-position='${theme.position}' data-flow='${theme.flow}'>
      <label title='Demo Settings' ${visible == 2 ? "style='display:none'" : ''} for='knobsToggle'>${settingsIcon}</label>
      <div class='knobs__bg'></div>
      <form class='knobs__labels'>
        <!-- Knobs goes here -->
        <section class='knobs__controls'>
          ${live ? '' : `<input type="submit" value="Apply">`}
          <input type="reset" value="↩ Reset" title="Reset to defaults">
          <a class='poweredBy' href='https://github.com/yairEO/knobs' target='_blank'>Get <em>Knobs</em></a>
        </section>
      </form>
    </aside>
  `;
	}
	function fieldset(knobsGroups) {
	  var legend, knobs;
	  if (isObject(knobsGroups[0])) {
	    knobs = knobsGroups;
	  } else {
	    [legend, ...knobs] = knobsGroups;
	    legend = getLegend(legend instanceof Array ? {
	      label: legend[0],
	      checked: !!legend[1]
	    } : {
	      label: legend,
	      checked: true
	    });
	  }
	  return `<fieldset ${legend ? 'data-has-legend' : ''}>
    ${legend ? legend : ''}
    <div class="fieldset__group">
      ${knobs.map(knob.bind(this)).join("")}
    </div>
  </fieldset>`;
	}
	function knob(data) {
	  if (data && data.type) return `<div class='knobs__knob'>
        <input type='checkbox' data-for-knob='${data.__name}' checked class='knobs__knob__toggle' title='Temporarily disable the knob' />
        <label data-type='${data.type}'>
          <div class='knobs__knob__label' ${data.cssVar && data.cssVar[1] ? `data-units='${data.cssVar[1].replace('-', '')}'` : ''}>${data.label}</div>
          <div class='knobs__knob__inputWrap'>
            ${getInput.call(this, data)}
          </div>
        </label>
        <button type='button' name='${data.__name}' class='knobs__knob__reset' title='Reset'>↩</button>
      </div>
    `;
	}
	function getLegend({
	  label,
	  checked
	}) {
	  var id = label.replace(/ /g, '-') + Math.random().toString(36).slice(-6);
	  return `<input hidden id="${id}" type="checkbox" ${checked ? "checked" : ""} class="toggleSection">
          <label class='knobs__legend' for="${id}" title="Expand/Collapse">${label}</label>`;
	}
	function getInput(data) {
	  let {
	    type,
	    step,
	    min,
	    max,
	    value
	  } = data;
	  if (type == 'range') return `
      <div class="range" style="--step:${step || 1}; --min:${min}; --max:${max}; --value:${value}; --text-value:'${value}'">
        <input type="range" ${this.knobAttrs(data)}>
        <output></output>
        <div class='range__progress'></div>
      </div>`;
	  if (type == 'checkbox') return `
      <div class="switch">
        <input type='${type}' ${this.knobAttrs(data)} class="switch__input">
        <div class='switch__gfx'></div>
      </div>`;
	  if (type == 'color') type = 'text';
	  return `<div><input type='${type}' data-type='${data.type}' ${this.knobAttrs(data)}></div>`;
	}

	const raf = window.requestAnimationFrame || (cb => window.setTimeout(cb, 1000 / 60));
	function bindEvents() {
	  this.eventsRefs = this.eventsRefs || {
	    change: e => {
	      if (!e.target.name) return;
	      this.setKnobChangedFlag(this.getKnobElm(e.target.name));
	      this.onChange(e);
	    },
	    input: e => {
	      const is = cls => e.target.classList.contains(cls);
	      try {
	        let isSectionToggler = is('toggleSection'),
	        groupElm;
	        if (isSectionToggler && e.target.checked) {
	          groupElm = e.target.parentNode.querySelector('.fieldset__group');
	          this.setIframeProps({
	            heightOffset: 999
	          });
	        }
	      } catch (err) {}
	      if (e.target.hasAttribute('is-knob-input')) {
	        this.onInput(e);
	        this.onChange(e);
	      } else if (is('knobs__knob__toggle')) this.toggleKnob(e.target.dataset.forKnob, e.target.checked);
	    },
	    transitionend: e => {
	      if (e.target.classList.contains('fieldset__group')) {
	        this.setIframeProps();
	      }
	    },
	    wheel: e => {
	      e.preventDefault();
	      const {
	        value,
	        max,
	        step
	      } = e.target,
	            delta = Math.sign(e.deltaY) * (+step || 1) * -1;
	      if (value && max) {
	        e.target.value = Math.min(Math.max(+value + delta, 0), +max);
	        this.onInput(e);
	        this.onChange(e);
	      }
	    },
	    mainToggler: e => this.toggle(e.target.checked),
	    reset: this.applyKnobs.bind(this, null, true),
	    submit: this.onSubmit.bind(this),
	    click: this.onClick.bind(this),
	    focusin: this.onFocus.bind(this)
	  };
	  [['form', 'change'], ['form', 'input'], ['form', 'reset'], ['form', 'submit'], ['form', 'focusin'], ['form', 'transitionend'], ['scope', 'click'], ['scope', 'wheel'], ['mainToggler', 'change', this.eventsRefs.mainToggler]].forEach(([elm, event, cb]) => this.DOM[elm].addEventListener(event, cb || this.eventsRefs[event].bind(this), {
	    passive: false
	  }));
	}
	function onFocus(e) {
	  if (e.target.dataset.type == 'color') setTimeout(_ => this.toggleColorPicker(e.target), 100);
	}
	function onInput(e) {
	  const inputElm = e.target,
	        value = inputElm.value,
	        {
	    label
	  } = this.getKnobDataByName(e.target.name);
	  inputElm.parentNode.style.setProperty('--value', value);
	  inputElm.parentNode.style.setProperty('--text-value', JSON.stringify(value));
	  this.setKnobDataByName(e.target.name, {
	    value
	  });
	  if (value != undefined && label)
	    this.getSetPersistedData({
	      [label]: inputElm.type == 'checkbox' ? [inputElm.checked, value] : value
	    });
	}
	function onChange(e) {
	  var knobData = this.getKnobDataByName(e.target.name),
	      runOnInput = e.type == 'input' && knobData && knobData.type != 'range',
	  isCheckbox = knobData && knobData.type == 'checkbox',
	      updatedData;
	  if (!knobData) return;
	  if (!isCheckbox && !this.settings.live) return;
	  if (e.type == 'input' && runOnInput) return;
	  raf(() => this.updateDOM(knobData));
	  typeof knobData.onChange == 'function' && knobData.onChange(e, updatedData);
	}
	function onSubmit(e) {
	  e.preventDefault();
	  var elements = e.target.querySelectorAll('input');
	  this.settings.live = true;
	  elements.forEach(elm => this.onChange({
	    target: {
	      value: elm.value,
	      name: elm.name
	    }
	  }));
	  this.settings.live = false;
	  return false;
	}
	function onClick(e) {
	  var target = e.target,
	      is = n => target.classList.contains(n);
	  if (is('knobs__knob__reset')) this.resetKnobByName(target.name);
	  this.hideColorPickers();
	}

	var events = /*#__PURE__*/Object.freeze({
		__proto__: null,
		bindEvents: bindEvents,
		onFocus: onFocus,
		onInput: onInput,
		onChange: onChange,
		onSubmit: onSubmit,
		onClick: onClick
	});

	function getSetPersistedData(data) {
	  let _store = this.settings.persist,
	      storeKey = '@yaireo/knobs/knobs',
	      customKey = typeof _store == 'string' ? '/' + _store : '',
	      persistedData = {};
	  try {
	    persistedData = JSON.parse(localStorage[storeKey + customKey]);
	  } catch (err) {}
	  if (_store && data) {
	    Object.assign(persistedData, data);
	    localStorage.setItem(storeKey + customKey, JSON.stringify(persistedData));
	    dispatchEvent(new Event('storage'));
	  }
	  return persistedData;
	}

	var persist = /*#__PURE__*/Object.freeze({
		__proto__: null,
		getSetPersistedData: getSetPersistedData
	});

	var DEFAULTS = {
	  visible: 0,
	  live: true,
	  theme: {
	    flow: 'horizontal',
	    styles: '',
	    RTL: false,
	    position: 'top right',
	    primaryColor: '#0366D6',
	    "range-value-background": '#FFF',
	    background: "rgba(0,0,0,1)",
	    textColor: "white",
	    border: 'none'
	  }
	};

	function Knobs(settings) {
	  if (!isModernBrowser()) return this;
	  const {
	    knobs = [],
	    ...restOfSettings
	  } = settings || {};
	  this.settings = mergeDeep({ ...DEFAULTS,
	    appendTo: document.body
	  }, restOfSettings);
	  this.knobs = knobs;
	  this.DOM = {};
	  this.state = {};
	  this.build();
	}
	Knobs.prototype = {
	  _types: ['range', 'color', 'checkbox', 'text'],
	  ...events,
	  ...persist,
	  cloneKnobs,
	  set knobs(knobs) {
	    if (knobs && knobs instanceof Array) {
	      this._knobs = this.cloneKnobs(knobs, this.getSetPersistedData());
	      this.DOM && this.render();
	    }
	  },
	  get knobs() {
	    return this._knobs;
	  },
	  getCSSVariables({
	    flow,
	    styles,
	    RTL,
	    position,
	    ...vars
	  }) {
	    var output = '',
	        p;
	    if (this.settings.knobsToggle) vars['knobs-toggle'] = 1;
	    for (p in vars) output += `--${p}:${vars[p]}; `;
	    return output;
	  },
	  getKnobValueFromCSSVar(data) {
	    let value;
	    if (!("value" in data) && data.cssVar && data.cssVar.length) {
	      let CSSVarTarget = data.cssVar[2] || this.settings.CSSVarTarget;
	      if (CSSVarTarget.length) CSSVarTarget = CSSVarTarget[0];
	      value = getComputedStyle(CSSVarTarget).getPropertyValue(`--${data.cssVar[0]}`).trim();
	      if (data.type == 'range') value = parseInt(value);
	      return value;
	    }
	  },
	  templates: {
	    scope: scope,
	    knob: knob,
	    fieldset: fieldset
	  },
	  hideColorPickers(exceptNode) {
	    document.querySelectorAll('.color-picker').forEach(elm => elm != exceptNode && elm.classList.add('hidden'));
	  },
	  toggleColorPicker(inputElm) {
	    const {
	      value
	    } = inputElm,
	    that = this;
	    const cPicker = inputElm.colorPicker || new colorPicker_min({
	      color: value,
	      className: 'hidden',
	      swatches: [],
	      swatchesLocalStorage: true,
	      onClickOutside(e) {
	        if (!cPicker.DOM.scope.classList.contains('hidden')) that.hideColorPickers(cPicker.DOM.scope);
	        let action = 'add';
	        if (e.target == inputElm) action = 'toggle';
	        if (e.key == 'Escape') action = 'add';
	        cPicker.DOM.scope.classList[action]('hidden');
	      },
	      onInput(color) {
	        inputElm.value = color;
	        that.onInput({
	          type: 'input',
	          target: inputElm
	        });
	        that.onChange({
	          type: 'change',
	          target: inputElm
	        });
	      }
	    });
	    if (!document.body.contains(cPicker.DOM.scope)) {
	      inputElm.colorPicker = cPicker;
	      document.body.appendChild(cPicker.DOM.scope);
	    }
	    r(this.DOM.iframe, cPicker.DOM.scope);
	    cPicker.DOM.scope.classList.remove('hidden');
	  },
	  knobAttrs(data) {
	    var attributes = `name="${data.__name}" is-knob-input`,
	        blacklist = ['label', 'type', 'onchange', 'cssvar', '__name'];
	    for (var attr in data) {
	      if (attr == 'checked' && !data[attr]) continue;
	      if (!blacklist.includes(attr.toLowerCase())) attributes += ` ${attr}="${data[attr]}"`;
	    }
	    return attributes;
	  },
	  getKnobDataByName(name) {
	    return this._knobs.filter(Boolean).find(d => d.__name == name);
	  },
	  setKnobDataByName(name, d) {
	    if (name && d && isObject(d)) {
	      const knobData = this.getKnobDataByName(name);
	      for (let key in d)
	      knobData[key] = +d[key] == d[key] ? +d[key] : d[key];
	    }
	  },
	  getInputByName(name) {
	    return this.DOM.scope.querySelector(`input[name="${name}"`);
	  },
	  getKnobElm(name) {
	    return this.getInputByName(name).closest('.knobs__knob');
	  },
	  updateDOM({
	    cssVar,
	    value,
	    type,
	    __name: name
	  }) {
	    if (!cssVar || !cssVar.length) return;
	    var [cssVarName, cssVarUnit, CSSVarTarget] = cssVar,
	        targetElms = CSSVarTarget || this.settings.CSSVarTarget,
	        knobInput = this.getInputByName(name),
	        action = 'setProperty';
	    if (type == 'checkbox' && knobInput && !knobInput.checked) action = 'removeProperty';
	    if (cssVarUnit && cssVarUnit[0] == '-') cssVarUnit = '';
	    if (Object.prototype.toString.call(targetElms).includes("Element")) targetElms = [targetElms];
	    if (targetElms && targetElms.length && value !== undefined && cssVarName) for (let elm of targetElms) elm.style[action](`--${cssVarName}`, value + (cssVarUnit || ''));
	  },
	  applyKnobs(knobsData, reset) {
	    (knobsData || this._knobs).forEach(d => {
	      if (!d || !d.type) return;
	      var isCheckbox = d.type == 'checkbox',
	          isRange = d.type == 'range',
	          inputElm = this.getInputByName(d.__name),
	          e = {
	        target: inputElm
	      },
	          vKey = reset ? 'defaultValue' : 'value',
	          checkedKey = reset ? 'defaultChecked' : 'checked',
	          resetTitle;
	      if (isCheckbox) {
	        resetTitle = inputElm.checked = !!d.checked;
	        inputElm.checked = d[checkedKey];
	      } else resetTitle = inputElm.value = d[vKey];
	      this.setResetKnobTitle(d.__name, resetTitle);
	      this.onInput(e);
	      this.onChange(e);
	      setTimeout(() => {
	        if (!isCheckbox) inputElm.value = d[vKey];
	      });
	      this.setKnobChangedFlag(this.getKnobElm(d.__name), d.value != d.defaultValue);
	    });
	  },
	  setResetKnobTitle(name, title) {
	    try {
	      title = "Reset to " + title;
	      this.getKnobElm(name).querySelector('.knobs__knob__reset').title = title;
	    } catch (err) {}
	  },
	  resetKnobByName(name) {
	    this.setKnobChangedFlag(this.getKnobElm(name), false);
	    this.applyKnobs([this.getKnobDataByName(name)], true);
	  },
	  calculateGroupsHeights() {
	    var groupElms = this.DOM.form.querySelectorAll('.fieldset__group');
	    groupElms.forEach(groupElm => {
	      groupElm.style.setProperty('--height', groupElm.clientHeight);
	    });
	  },
	  setIframeProps(opts) {
	    var action = (this.state.visible == false ? 'remove' : 'set') + 'Property',
	    style = this.DOM.iframe.style,
	        {
	      heightOffset = 0
	    } = opts || {};
	    if (action == 'setProperty') {
	      style.setProperty(`--knobsWidth`, '2000px');
	      style.setProperty(`--knobsHeight`, '1000px');
	    }
	    var {
	      clientWidth,
	      clientHeight
	    } = this.DOM.scope;
	    style[action](`--knobsWidth`, clientWidth + 'px');
	    style[action](`--knobsHeight`, +clientHeight + +heightOffset + 'px');
	  },
	  toggle(state) {
	    if (state === undefined) state = !this.DOM.mainToggler.checked;
	    this.state.visible = state;
	    this.DOM.mainToggler.checked = state;
	    this.setIframeProps();
	  },
	  toggleKnob(name, isToggled) {
	    let knobData = this.getKnobDataByName(name),
	        key = knobData.type == 'checkbox' ? 'checked' : 'value';
	    knobData = isToggled ? { ...knobData,
	      [key]: key == 'checked' ? knobData.checked : knobData.value
	    } : { ...knobData,
	      [key]: key == 'checked' ? knobData.defaultChecked : knobData.defaultValue
	    };
	    this.updateDOM(knobData);
	  },
	  build() {
	    this.createIframe();
	    setTimeout(this.bindEvents.bind(this));
	  },
	  createIframe() {
	    var iframeDoc,
	        theme = this.settings.theme,
	        cssText;
	    this.DOM.iframe = document.createElement('iframe');
	    this.DOM.iframe.setAttribute('class', 'knobsIframe');
	    this.DOM.iframe.style.cssText = `
        border: none;
        position: fixed;
        z-index: 999999;
        ${(theme.position + " ").split(" ").join(":0;")}
        width: var(--knobsWidth, 56px);
        height: var(--knobsHeight, 56px);
    `;
	    this.settings.appendTo.appendChild(this.DOM.iframe);
	    iframeDoc = this.DOM.iframe.contentWindow.document;
	    iframeDoc.open();
	    iframeDoc.write(this.templates.scope.call(this));
	    cssText = `.knobs{ ${this.getCSSVariables(theme)} }`;
	    cssText += mainStyles + theme.styles;
	    iframeDoc.head.insertAdjacentHTML("beforeend", `<style>${cssText}</style>`);
	    iframeDoc.close();
	    this.DOM.scope = iframeDoc.body.querySelector('.knobs');
	    this.DOM.form = this.DOM.scope.querySelector('form');
	    this.DOM.mainToggler = iframeDoc.getElementById('knobsToggle');
	    this.render();
	  },
	  render() {
	    var knobsGroups = this._knobs.reduce((acc, knobData) => {
	      if (knobData && !isObject(knobData) && acc[acc.length - 1].length) acc.push([]);
	      acc[acc.length - 1].push(knobData);
	      return acc;
	    }, [[]]);
	    this.DOM.form.querySelectorAll('fieldset').forEach(elm => elm.remove());
	    var HTML = knobsGroups.map(this.templates.fieldset.bind(this)).join("");
	    this.DOM.form.insertAdjacentHTML('afterbegin', HTML);
	    this.calculateGroupsHeights();
	    this.toggle(this.DOM.mainToggler.checked);
	    this.applyKnobs();
	    const colorPickerCSSExists = [...document.styleSheets].some(s => s.title == 'color-picker');
	    if (!colorPickerCSSExists) document.head.insertAdjacentHTML('beforeend', `<style title='color-picker'>
      ${colorPickerStyles}
      .color-picker[style~='left:']{ z-index: 999999; position: fixed; }
      </style>`);
	  },
	  setKnobChangedFlag(knobElm, action) {
	    knobElm && knobElm[(action == false ? 'remove' : 'set') + 'Attribute']('data-changed', true);
	  }
	};

	return Knobs;

})));
